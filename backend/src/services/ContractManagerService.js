const { PDFDocument, StandardFonts, rgb } = require('pdf-lib');
const fs = require('fs');
const path = require('path');

const __dirname = path.dirname(__filename);

class ContractManagerService {
  constructor() {
    this.templatesDir = path.join(__dirname, '../templates/contracts');
    this.outputDir = path.join(__dirname, '../../../storage/contracts');
    
    // Ensure directories exist
    this.ensureDirectories();
  }

  ensureDirectories() {
    [this.templatesDir, this.outputDir].forEach(dir => {
      if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
      }
    });
  }

  /**
   * Generate a contract PDF for a finalized deal
   * @param {Object} contractData - Deal and creator information
   * @returns {Object} Contract generation result
   */
  async generateContract(contractData) {
    try {
      const {
        campaignId,
        creatorId,
        creatorName,
        creatorEmail,
        brandName,
        campaignTitle,
        deliverables = [],
        paymentAmount,
        paymentMilestones = [],
        deadlines = {},
        agreementDate = new Date(),
        contractId = `CONTRACT-${Date.now()}`
      } = contractData;

      console.log(`üìÑ Generating contract ${contractId} for ${creatorName}...`);

      // Create a new PDF document
      const pdfDoc = await PDFDocument.create();
      
      // Embed standard font
      const font = await pdfDoc.embedFont(StandardFonts.Helvetica);
      const boldFont = await pdfDoc.embedFont(StandardFonts.HelveticaBold);

      // Add pages and content
      let page = pdfDoc.addPage([612, 792]); // Letter size
      const { width, height } = page.getSize();

      // Title
      page.drawText('INFLUENCER MARKETING AGREEMENT', {
        x: 50,
        y: height - 50,
        size: 20,
        font: boldFont,
        color: rgb(0, 0, 0),
      });

      // Contract details
      let yPosition = height - 100;
      const lineHeight = 20;

      const contractContent = [
        `Contract ID: ${contractId}`,
        `Date: ${agreementDate.toDateString()}`,
        ``,
        `PARTIES:`,
        `Brand: ${brandName}`,
        `Creator: ${creatorName} (${creatorEmail})`,
        ``,
        `CAMPAIGN DETAILS:`,
        `Campaign: ${campaignTitle}`,
        ``,
        `DELIVERABLES:`,
        ...deliverables.map((d, i) => `${i + 1}. ${d.description || d}`),
        ``,
        `COMPENSATION:`,
        `Total Amount: $${paymentAmount}`,
        ``,
        `PAYMENT SCHEDULE:`,
        ...paymentMilestones.map((milestone, i) => 
          `${i + 1}. ${milestone.description || milestone.phase}: $${milestone.amount} - Due: ${milestone.dueDate || 'TBD'}`
        ),
        ``,
        `DEADLINES:`,
        `Content Creation: ${deadlines.contentCreation || 'TBD'}`,
        `Campaign Launch: ${deadlines.campaignLaunch || 'TBD'}`,
        `Final Reporting: ${deadlines.finalReporting || 'TBD'}`,
        ``,
        `TERMS AND CONDITIONS:`,
        `1. Creator agrees to produce high-quality content as specified.`,
        `2. All content must be approved by Brand before publication.`,
        `3. Creator retains ownership of content but grants Brand usage rights.`,
        `4. Payment will be made according to the schedule outlined above.`,
        `5. Either party may terminate with 7 days written notice.`,
        `6. Creator must disclose sponsored content per FTC guidelines.`,
        ``,
        `SIGNATURES:`,
        ``,
        `Brand Representative: ___________________________ Date: ___________`,
        ``,
        `Creator: ___________________________ Date: ___________`,
        ``,
        `This contract is generated by InfluencerFlow AI Platform`,
        `For questions, contact: contracts@influencerflow.com`
      ];

      // Draw contract content
      contractContent.forEach(line => {
        if (yPosition < 50) {
          // Add new page if needed
          const newPage = pdfDoc.addPage([612, 792]);
          yPosition = height - 50;
          page = newPage;
        }

        const fontSize = line.includes('PARTIES:') || line.includes('CAMPAIGN DETAILS:') || 
                        line.includes('DELIVERABLES:') || line.includes('COMPENSATION:') || 
                        line.includes('PAYMENT SCHEDULE:') || line.includes('DEADLINES:') || 
                        line.includes('TERMS AND CONDITIONS:') || line.includes('SIGNATURES:') ? 14 : 12;
        
        const useFont = fontSize === 14 ? boldFont : font;

        page.drawText(line, {
          x: 50,
          y: yPosition,
          size: fontSize,
          font: useFont,
          color: rgb(0, 0, 0),
        });

        yPosition -= lineHeight;
      });

      // Save the PDF
      const pdfBytes = await pdfDoc.save();
      const contractPath = path.join(this.outputDir, `${contractId}.pdf`);
      
      fs.writeFileSync(contractPath, pdfBytes);

      console.log(`‚úÖ Contract generated successfully: ${contractPath}`);

      return {
        success: true,
        contractId,
        contractPath,
        fileName: `${contractId}.pdf`,
        size: pdfBytes.length,
        createdAt: new Date().toISOString(),
        status: 'generated'
      };

    } catch (error) {
      console.error('‚ùå Contract generation failed:', error);
      return {
        success: false,
        error: error.message
      };
    }
  }

  /**
   * Get contract status and details
   * @param {string} contractId - Contract identifier
   * @returns {Object} Contract status
   */
  getContractStatus(contractId) {
    try {
      const contractPath = path.join(this.outputDir, `${contractId}.pdf`);
      
      if (fs.existsSync(contractPath)) {
        const stats = fs.statSync(contractPath);
        return {
          contractId,
          status: 'ready',
          createdAt: stats.birthtime.toISOString(),
          size: stats.size,
          path: contractPath
        };
      }

      return {
        contractId,
        status: 'not_found'
      };
    } catch (error) {
      return {
        contractId,
        status: 'error',
        error: error.message
      };
    }
  }

  /**
   * List all generated contracts
   * @returns {Array} List of contracts
   */
  listContracts() {
    try {
      const files = fs.readdirSync(this.outputDir)
        .filter(file => file.endsWith('.pdf'))
        .map(file => {
          const contractPath = path.join(this.outputDir, file);
          const stats = fs.statSync(contractPath);
          return {
            contractId: file.replace('.pdf', ''),
            fileName: file,
            createdAt: stats.birthtime.toISOString(),
            size: stats.size,
            status: 'ready'
          };
        })
        .sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));

      return files;
    } catch (error) {
      console.error('‚ùå Failed to list contracts:', error);
      return [];
    }
  }

  /**
   * Delete a contract file
   * @param {string} contractId - Contract identifier
   * @returns {Object} Deletion result
   */
  deleteContract(contractId) {
    try {
      const contractPath = path.join(this.outputDir, `${contractId}.pdf`);
      
      if (fs.existsSync(contractPath)) {
        fs.unlinkSync(contractPath);
        return {
          success: true,
          message: `Contract ${contractId} deleted successfully`
        };
      }

      return {
        success: false,
        message: 'Contract not found'
      };
    } catch (error) {
      return {
        success: false,
        error: error.message
      };
    }
  }
}

module.exports = ContractManagerService; 